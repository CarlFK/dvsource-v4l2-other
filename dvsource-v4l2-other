#! /usr/bin/python
#
# -*- coding: utf-8 -*-
# vim: set ts=4 sw=4 et sts=4 ai:
#

"""
dvsource-v4l2-other - Video4Linux2 source for DVswitch which supports any device.
"""

import argparse
import atexit
import os
import tempfile
import time
import subprocess
import shutil

import gobject
gobject.threads_init()

import pygst
pygst.require('0.10')
import gst


subprocess.DEVNULL = file(os.devnull, "rw+")

###############################################################################
# Argument parsing
###############################################################################

parser = argparse.ArgumentParser(add_help=False)
parser.add_argument(
    "-d", "--device", default="/dev/video0",
    help="Video4Linux device to read the input from.")

parser.add_argument(
    "-f", "--format", default="ntsc", choices=["ntsc", "pal"],
    help="Choose DV output format.")
parser.add_argument(
    "-a", "--aspect", default="4:3", choices=["4:3", "16:9"],
    help="Choose DV output aspect ratio.")
parser.add_argument(
    "-t", "--timeout", type=int, default=10,
    help="How long to wait when terminating subprocess before killing.")

fake_types = {
    None: 0,
    "": 0,
    "smpte": 0,
    "snow": 1,
    "black": 2,
    "white": 3,
    "red": 4,
    "green": 5,
    "blue": 6,
    "checkers-1": 7,
    "checkers-2": 8,
    "checkers-4": 9,
    "checkers-8": 10,
    "circular": 11,
    "blink": 12,
    "smpte": 13,
    "zone-plate": 14,
    "gamut": 15,
    "chroma-zone-plate": 16,
    "solid-color": 17,
    "ball": 18,
    "smpte": 19,
    "bar": 20,
    }
parser.add_argument(
    "-n", "--fake", choices=fake_types.keys(),
    help="Use a fake source rather then a real V4L2 device.")

parser.add_argument(
    "-v", "--verbose", action="store_true",
    help="Increase output verbosity")

# dvswitch arguments
parser.add_argument(
    "-h", "--host", 
    help=(""
        "Specify the network address on which DVswitch is listening. The host"
        " address may be specified by name or as an IPv4 or IPv6 literal.")
    )
parser.add_argument(
    "-p", "--port",
    help=(""
        "Specify the network address on which DVswitch is listening. The host"
        " address may be specified by name or as an IPv4 or IPv6 literal.")
    )
parser.add_argument(
    "--help", action='help',
    help="show this help message and exit")

###############################################################################
# Code to check dependencies
###############################################################################
def check_command(name):
    try:
        output = subprocess.check_output(["which", name])
        if args.verbose:
          print "Using", name, "found at", output.strip()
    except subprocess.CalledProcessError, e:
        print "Unable to find required command:", name
        raise

def check_gst_module(name):
    try:
        subprocess.check_call(["gst-inspect-0.10", name], stdout=subprocess.DEVNULL)
    except subprocess.CalledProcessError, e:
        print "Unable to find required gstreamer module", name
        raise

###############################################################################
# Code to which actually does the work
###############################################################################
def create_fifo():
    tmpdir = tempfile.mkdtemp()
    def cleanup_fifo():
      def print_error(e):
         print e
      shutil.rmtree(tmpdir, False, print_error)
    atexit.register(cleanup_fifo)

    fifoname = os.path.join(tmpdir, 'fifo.dv')
    if args.verbose:
        print "Making fifo at ", fifoname
    os.mkfifo(fifoname)
    return fifoname


def launch_gstreamer(fifoname):

    cmd = ("" +
        {True:
            # Read the v4l2 input and decode it if it's a mjpeg input
            "v4l2src ! decodebin2 !",
         False:
          "videotestsrc is-live=true pattern=%s !" % fake_types[args.fake],
        }[args.fake == None] +
        " " +
        # Allow at most 1ms of data to be in the buffer, 2=GST_QUEUE_LEAK_DOWNSTREAM
        "queue name=firstqueue leaky=2 max-size-buffers=5 ! " +
        " " +
        # Convert to 4:3 format by adding borders if needed
        {"4:3":
            # Convert to 4:3 format by adding borders if needed
            "videoscale add-borders=1 ! video/x-raw-yuv,width=1024,height=768,pixel-aspect-ratio=(fraction)1/1 !",
         "16:9":
            # Convert to 16:9 format by adding borders if needed
            "videoscale add-borders=1 ! video/x-raw-yuv,width=1280,height=720,pixel-aspect-ratio=(fraction)1/1 !",
        }[args.aspect] +
        " " +
        "queue ! " +
        " " +
        {"ntsc-4:3": 
            # Convert to 4:3 with non-square pixels
            "videoscale ! video/x-raw-yuv,width=720,height=480,pixel-aspect-ratio=(fraction)10/11 !",
         "ntsc-16:9": 
            # Convert to 4:3 with non-square pixels
            "videoscale ! video/x-raw-yuv,width=720,height=480,pixel-aspect-ratio=(fraction)40/33 !",
         "pal-4:3":
            # Convert to 4:3 with non-square pixels
            "videoscale ! video/x-raw-yuv,width=720,height=576,pixel-aspect-ratio=(fraction)59/54 !",
         "pal-4:3":
            # Convert to 4:3 with non-square pixels
            "videoscale ! video/x-raw-yuv,width=720,height=576,pixel-aspect-ratio=(fraction)118/81 !",
        }["%s-%s" % (args.format, args.aspect)] +
        " " +
        "queue ! " +
        " " +
        {"ntsc": 
            # Convert the framerate to 30fps
            "videorate ! video/x-raw-yuv,framerate=(fraction)30000/1001 !",
         "pal":
            # Convert the framerate to 25fps
            "videorate ! video/x-raw-yuv,framerate=(fraction)25/1 !",
        }[args.format] +
        " " +
        # Convert to DV format
        "ffmpegcolorspace ! ffenc_dvvideo ! ffmux_dv !" +
        " " +
        "queue ! " +
        " " +
        # Output to the fifo
        "filesink location=" + fifoname)

    if args.verbose:
        print "Using a gstreamer pipeline of", cmd
    try:
        pipeline = gst.parse_launch(cmd)
    except gobject.GError, e:
        raise OSError('Could not create pipeline: %s' % str(e))
    
    def on_message(bus, message):
        t = message.type
        print "Message:", message,
        if t == gst.MESSAGE_STATE_CHANGED:
            pass
        elif t == gst.MESSAGE_ERROR:
            err, debug = message.parse_error()
            print err, debug,
        elif t == gst.MESSAGE_EOS:
            print "EOS!?",
        else:
            print '%s: %s:' % (
                message.src.get_path_string(), message.type.value_nicks[1]),
            if message.structure:
                print '    %s' % message.structure.to_string(),
            else:
                print '    (no structure)',
        print
        return True

    bus = pipeline.get_bus()
    bus.add_signal_watch()
    watch_id = bus.connect('message', on_message)

    #def queue_message(message):
    #    print message.type
    #queue = pipeline.get_by_name('firstqueue')
    #queue.connect('overrun', queue_message)
    #queue.connect('running', queue_message)
    #queue.connect('underrun', queue_message)
    #queue.connect('pushing', queue_message)

    pipeline.set_state(gst.STATE_PLAYING)

    return pipeline


def launch_dvsource(fifoname):
    cmd = "dvsource-file "
    if args.host:
       cmd += "--host " + args.host + " "
    if args.port:
       cmd += "--port " + args.port + " "
    cmd += fifoname

    cmdargs = {}
    if args.verbose:
        print "Running the dvsource-file command of"
        print "   ", cmd
    else:
        cmdargs["stdout"] = subprocess.DEVNULL

    return subprocess.Popen(cmd, shell=True, **cmdargs)


###############################################################################
# Main function
###############################################################################
def main():
    # Check that dvsource-file is installed
    check_command("dvsource-file")
    # Check that gstreamer stuff is installed
    check_command("gst-inspect-0.10")
    check_command("gst-launch-0.10")
    check_gst_module("v4l2src")
    check_gst_module("decodebin2")
    check_gst_module("videoscale")
    check_gst_module("videorate")
    check_gst_module("ffmpegcolorspace")
    check_gst_module("ffenc_dvvideo")
    check_gst_module("ffmux_dv")
    check_gst_module("filesink")

    # Create the fifo
    fifoname = create_fifo()
    # Launch the sub-commands
    dvsource = launch_dvsource(fifoname)
    pipeline = launch_gstreamer(fifoname)

    try:
        loop = gobject.MainLoop()
        context = loop.get_context()

        while True:
            while context.iteration(False):
                continue

            if dvsource.poll() != None:
                raise OSError("dvsource-file command terminated!")

            # FIXME: Add some type of monitoring of CPU usage here...
            if args.verbose:
                print "Commands happily running!"

                print pipeline.get_state()

                late = gst.query_new_latency()
                print pipeline.query(late),
                print late.parse_latency()

                buff = gst.query_new_buffering(gst.FORMAT_TIME)
                print pipeline.query(buff),
                print buff.parse_buffering_stats()

            time.sleep(1.0)
    finally:
        pipeline.set_state(gst.STATE_NULL)

        exitstart = time.time()

        try:
            if args.verbose:
                print "Terminating dvsource-file"
            dvsource.terminate()
        except Exception, e:
            print "Error terminating dvsource-file", e

        while True:
            if dvsource.poll() != None:
                break

            if args.verbose:
                print "Waiting for dvsource / gst-launch to terminate"
            time.sleep(1)

            if time.time() - exitstart > args.timeout:
                print "Timeout waiting for dvsource / gst-launch",
                print "to terminate, killing."

		try:
		    dvsource.kill()
		except Exception, e:
		    print "Error killing dvsource-file", e

args = None
if __name__ == "__main__":
    args = parser.parse_args()
    main()
